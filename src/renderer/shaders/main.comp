#version 460
#extension GL_EXT_nonuniform_qualifier : require
// <----------------------Specialization Constants---------------------------->

layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;
layout (constant_id = 2) const uint MATERIAL_COUNT = 1;
layout (constant_id = 3) const uint DIRECTIONAL_LIGHT_COUNT = 1;
layout (constant_id = 4) const uint POINT_LIGHT_COUNT = 1;
layout (constant_id = 5) const uint BVH_MAX_DEPTH = 16;

#define PI 3.1415926535
#define GAMMA 2.2
#define INFINITY 3.4e+38
#define NORMAL_DELTA 1e-3
#define POINT_LIGHT_RADIUS 0.2
#define MAX_TRANSPARENCY_BOUNCES 4
#define MAX_LIGHT_BOUNCES 4
const float epsilon = 1e-6;

// <--------------------------------Structs----------------------------------->

struct Vertex {
  vec3 pos;
  vec3 normal;
  float uv_u;
  vec3 tangent;
  float uv_v;
  vec3 bitangent;
  uint material_idx;
};

struct BVHNode {
  vec3 aabb_min;
  uint left_or_begin;
  vec3 aabb_max;
  uint tri_count;
};

struct Material {
  vec4 base_color;
  int base_color_texture_idx;

  float metallic;
  float roughness;
  int metallic_roughness_texture_idx;

  float normal_scale;
  int normal_texture_idx;

  float occlusion_strength;
  int occlusion_texture_idx;
  
  vec3 emissive_factor;
  int emissive_texture_idx;
};

struct DirectionalLight {
  vec3 color;
  float intensity;
  vec3 dir;
};

struct PointLight {
  vec3 color;
  float intensity;
  vec3 pos;
};

struct Camera {
  vec3 pos;
  vec3 pixel_delta_u, pixel_delta_v;
  vec3 corner_pixel_pos;
};

struct Ray {
  vec3 origin;
  vec3 dir;
};

struct IntersectInfo {
  float t;
  float u, v;
  uint triangle_idx;
};

// <------------------------------Descriptors--------------------------------->

layout (set = 0, binding = 0) buffer position_SSBO {
  vec3 positions[][3];
};

layout (set = 0, binding = 1) readonly buffer triangle_SSBO {
  Vertex triangles[][3];
};

layout (set = 0, binding = 2) readonly buffer bvh_SSBO {
  BVHNode bvh_nodes[];
};

layout (set = 0, binding = 3) uniform material_UBO {
  Material materials[MATERIAL_COUNT];
};

layout (set = 0, binding = 4) uniform directional_light_UBO {
  DirectionalLight directional_lights[DIRECTIONAL_LIGHT_COUNT + 1];
};

layout (set = 0, binding = 5) uniform point_light_UBO {
  PointLight point_lights[POINT_LIGHT_COUNT + 1];
};

layout (set = 0, binding = 6) uniform sampler2D textures[];

layout (set = 0, binding = 7, rgba8) uniform writeonly image2D result;

layout (push_constant) uniform constant {
  Camera camera;
  uint resolution_x, resolution_y;
  uint seed;
  uint sample_count;
  vec3 bg_color_srgb;
};

// <----------------------------------RNG------------------------------------->

// https://nullprogram.com/blog/2018/07/31/
void triple32(inout uint x) {
  x ^= x >> 17;
  x *= 0xed5ad4bbU;
  x ^= x >> 11;
  x *= 0xac4c1b51U;
  x ^= x >> 15;
  x *= 0x31848babU;
  x ^= x >> 14;
}

uint rand_state;
float rand_float() {
  triple32(rand_state);
  return float(rand_state) / float(~0u);
}

vec3 rand_dir() {
  float z = 2.0 * rand_float() - 1.0;
  float l = sqrt(1.0 - z * z);
  float theta = 2.0 * PI * rand_float();
  return vec3(l * cos(theta), l * sin(theta), z);
}

mat3 orthogonal_matrix(vec3 w) {
  vec3 a = (abs(w.x) > 0.9 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0));
  vec3 v = normalize(cross(w, a));
  vec3 u = cross(w, v);
  return mat3(u, v, w);
}

// <-------------------------Ray-AABB-Intersection---------------------------->

bool ray_aabb_intersect(const Ray ray, const vec3 aabb_min, const vec3 aabb_max, out float t) {
  vec3 inv_dir = 1.0 / ray.dir;
  vec3 t_min = inv_dir * (aabb_min - ray.origin);
  vec3 t_max = inv_dir * (aabb_max - ray.origin);
  vec3 t1 = min(t_min, t_max);
  vec3 t2 = max(t_min, t_max);
  float t_near = max(max(t1.x, t1.y), t1.z);
  float t_far  = min(min(t2.x, t2.y), t2.z);

  t = t_near;
  if (t_near <= t_far) {
    return true;

  } else {
    return false;
  }
}

// <---------------------Ray-Triangle-Intersection---------------------------->

void ray_triangle_intersect(
    const Ray ray,
    const uint triangle_idx,
    inout IntersectInfo info) {

  vec3 pos[3] = positions[triangle_idx];
  vec3 edge1 = pos[1] - pos[0];
  vec3 edge2 = pos[2] - pos[0];
  vec3 ray_cross_edge2 = cross(ray.dir, edge2);
  float det = dot(edge1, ray_cross_edge2);
  if (abs(det) < epsilon) return;

  float inv_det = 1.0 / det;
  vec3 s = ray.origin - pos[0];
  float u = inv_det * dot(s, ray_cross_edge2);
  if (u < 0.0 || u > 1.0) return;

  vec3 s_cross_edge1 = cross(s, edge1);
  float v = inv_det * dot(ray.dir, s_cross_edge1);
  if (v < 0.0 || u + v > 1.0) return;

  float t = inv_det * dot(edge2, s_cross_edge1);
  if (t > epsilon && t < info.t) {
    info.t = t;
    info.u = u;
    info.v = v;
    info.triangle_idx = triangle_idx;
  }
}

// <-------------------------Ray-Scene-Intersection--------------------------->

#define MIN_STACK_SIZE 64
const uint STACK_SIZE = MIN_STACK_SIZE * (BVH_MAX_DEPTH + MIN_STACK_SIZE - 1) / MIN_STACK_SIZE;
uint stack[STACK_SIZE];
void ray_scene_intersect(const Ray ray, inout IntersectInfo info) {
  uint top = 0;
  stack[top++] = 0;

  while (top != 0) {
    BVHNode node = bvh_nodes[stack[--top]];

    if (node.tri_count > 0) {
      for (uint i = 0; i < node.tri_count; ++i) {
        ray_triangle_intersect(ray, node.left_or_begin + i, info);
      }
    } else {
      BVHNode left  = bvh_nodes[node.left_or_begin];
      BVHNode right = bvh_nodes[node.left_or_begin + 1];

      float dist_left, dist_right;
      bool left_intersected  = ray_aabb_intersect(ray, left.aabb_min, left.aabb_max, dist_left);
      bool right_intersected = ray_aabb_intersect(ray, right.aabb_min, right.aabb_max, dist_right);
      left_intersected  = left_intersected  && (dist_left  < info.t);
      right_intersected = right_intersected && (dist_right < info.t);

      if (left_intersected && right_intersected) {
        if (dist_left < dist_right) {
          stack[top++] = node.left_or_begin + 1;
          stack[top++] = node.left_or_begin;
        } else {
          stack[top++] = node.left_or_begin;
          stack[top++] = node.left_or_begin + 1;
        }

      } else if (left_intersected) {
        stack[top++] = node.left_or_begin;

      } else if (right_intersected) {
        stack[top++] = node.left_or_begin + 1;
      }
    }
  }
}

// <-----------------------------Utility-------------------------------------->

vec4 sample_texture(uint index, vec2 texcoord) {
  if (index == -1) return vec4(1.0);
  return texture(textures[nonuniformEXT(index)], texcoord);
}

void get_interpolated_data(IntersectInfo intersect_info, 
    out vec3 pos, out vec3 normal, out vec2 texcoord, out uint material_idx) {
  Vertex vertices[3] = triangles[intersect_info.triangle_idx];
  float u = intersect_info.u;
  float v = intersect_info.v;
  float w = 1.0 - u - v;

  pos = w * vertices[0].pos + u * vertices[1].pos + v * vertices[2].pos;
  normal = normalize(w * vertices[0].normal + u * vertices[1].normal + v * vertices[2].normal);
  texcoord = 
    w * vec2(vertices[0].uv_u, vertices[0].uv_v) +
    u * vec2(vertices[1].uv_u, vertices[1].uv_v) +
    v * vec2(vertices[2].uv_u, vertices[2].uv_v);
  material_idx = vertices[0].material_idx;
}

void get_material_data(uint material_idx, vec2 texcoord,
    out vec3 base_color, out float alpha, out float metallic,
    out float roughness, out vec3 emission, out float occlusion) {

  Material mat = materials[material_idx];
  
  vec4 base_color_srgb = sample_texture(mat.base_color_texture_idx, texcoord);
  base_color = mat.base_color.rgb * pow(base_color_srgb.rgb, vec3(GAMMA));
  alpha = mat.base_color.a * base_color_srgb.a;

  vec2 roughness_metallic = sample_texture(mat.metallic_roughness_texture_idx, texcoord).bg;
  metallic = mat.metallic * roughness_metallic[0];
  roughness = mat.roughness * roughness_metallic[1];

  emission = mat.emissive_factor * pow(sample_texture(mat.emissive_texture_idx, texcoord).rgb, vec3(GAMMA));

  occlusion = 1.0 + mat.occlusion_strength * (sample_texture(mat.occlusion_texture_idx, texcoord).r - 1.0);
}

// <--------------------------------BRDF-------------------------------------->

float distribution_GGX(float n_dot_h, float a2) {
  if (a2 < epsilon && n_dot_h > 1.0 - epsilon) return 1.0;

  float denom = n_dot_h * n_dot_h * (a2 - 1.0) + 1.0;
  denom = PI * denom * denom;
  return a2 / denom;
}

float geometry_smith1(vec3 n, vec3 h, vec3 x, float a2) {
  if (dot(h, x) <= 0.0) return 0.0;

  float n_dot_x = dot(n, x);
  float denom = abs(n_dot_x) + sqrt(a2 + (1.0 - a2) * n_dot_x * n_dot_x);
  return 1.0 / denom;
}

float geometry_smith2(vec3 n, vec3 h, vec3 v, vec3 l, float a2) {
  return geometry_smith1(n, h, l, a2) * geometry_smith1(n, h, v, a2);
}

vec3 microfacet_brdf(vec3 n, vec3 v, vec3 l, float metal, float a2, vec3 base_color) {
  vec3 h = normalize(l + v);
  float n_dot_h = max(dot(n, h), epsilon);

  vec3 f0 = mix(vec3(0.04), base_color, metal);
  vec3 f = f0 + (1.0 - f0) * pow(1.0 - abs(dot(v, h)), 5.0);

  vec3 diffuse = (1.0 - f) * (1.0 - metal) * base_color / PI;
  vec3 specular = f * distribution_GGX(n_dot_h, a2) * geometry_smith2(n, h, l, v, a2);
  return diffuse + specular;
}

// <------------------------------Sampling------------------------------------>

vec3 diffuse_sample(vec3 n, out float pdf) {
  float phi = 2.0 * PI * rand_float();
  float rand = rand_float();

  vec3 l_local = vec3(cos(phi) * sqrt(rand), sin(phi) * sqrt(rand), sqrt(1.0 - rand));
  vec3 l = orthogonal_matrix(n) * l_local;

  float n_dot_l = max(dot(n, l), 0.0);
  pdf = n_dot_l / PI;

  return l;
}

vec3 microfacet_sample(vec3 n, vec3 v, float a2, out float pdf) {
  float phi = 2.0 * PI * rand_float();
  float rand = rand_float();
  float cos2_theta = clamp((1.0 - rand) / (rand * (a2 - 1) + 1), 0.0, 1.0);
  float cos_theta = sqrt(cos2_theta);
  float sin_theta = sqrt(1.0 - cos2_theta);

  vec3 h_local = vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);
  vec3 h = normalize(orthogonal_matrix(n) * h_local);
  vec3 l = reflect(-v, h);

  pdf = distribution_GGX(cos_theta, a2) * cos_theta / (4.0 * abs(dot(h, l)));

  return l;
}
// <--------------------------Direct-Lighting--------------------------------->

vec3 sample_direct(vec3 n, vec3 v, vec3 pos, float metal, float a2, vec3 base_color) {
  vec3 color = vec3(0.0);

  for (uint i = 0; i < DIRECTIONAL_LIGHT_COUNT; ++i) {
    DirectionalLight light = directional_lights[i];
    vec3 l = -light.dir;

    float n_dot_l = max(dot(n, l), 0.0);
    if (n_dot_l == 0.0) continue;

    IntersectInfo info;
    info.t = INFINITY;
    info.triangle_idx = -1;
    Ray ray;
    ray.origin = pos + NORMAL_DELTA * n;
    ray.dir = l;
    ray_scene_intersect(ray, info);
    if (info.triangle_idx != -1) continue;

    light.intensity *= (4.0 * PI / 683.0);
    vec3 radiance = light.color * light.intensity;

    color += radiance * microfacet_brdf(n, v, l, metal, a2, base_color) * n_dot_l;
  }

  for (uint i = 0; i < POINT_LIGHT_COUNT; ++i) {
    PointLight light = point_lights[i];

    light.pos += rand_dir() * POINT_LIGHT_RADIUS;
    vec3 l = light.pos - pos;
    float dist2 = dot(l, l);
    l = normalize(l);

    float n_dot_l = max(dot(n, l), 0.0);
    if (n_dot_l == 0.0) continue;

    IntersectInfo info;
    info.t = INFINITY;
    info.triangle_idx = -1;
    Ray ray;
    ray.origin = pos + NORMAL_DELTA * n;
    ray.dir = l;
    ray_scene_intersect(ray, info);
    if (info.triangle_idx != -1 && info.t * info.t < dist2) continue;

    float pdf = dist2 / (n_dot_l * PI * POINT_LIGHT_RADIUS * POINT_LIGHT_RADIUS);
    vec3 radiance = light.color * light.intensity;
    color += radiance * microfacet_brdf(n, v, l, metal, a2, base_color) * n_dot_l / pdf;
  }

  return color;
}

// <-----------------------------Path-Tracing--------------------------------->

vec3 get_ray_color(Ray ray) {
  const vec3 bg_color = pow(bg_color_srgb, vec3(GAMMA));
  vec3 color = vec3(0.0);
  vec3 indirect = vec3(1.0);

  uint transparency_bounces = 0;
  uint light_bounces = 0;
  while (light_bounces < MAX_LIGHT_BOUNCES) {
    IntersectInfo intersect_info;
    intersect_info.t = INFINITY;
    intersect_info.triangle_idx = -1;
    ray_scene_intersect(ray, intersect_info);
    if (intersect_info.triangle_idx == -1) {
      color += indirect * bg_color;
      break;
    }

    vec3 pos, n;
    vec2 uv;
    uint mat_idx;
    get_interpolated_data(intersect_info, pos, n, uv, mat_idx);
    if (dot(n, ray.dir) > 0.0) n *= -1.0;

    vec3 base_color, emission;
    float alpha, roughness, metal, occlusion;
    get_material_data(
      mat_idx, uv,
      base_color, alpha, metal,
      roughness, emission, occlusion
    );
    float a = roughness * roughness;
    float a2 = a * a;

    vec3 direct_lighting = emission + sample_direct(n, -ray.dir, pos, metal, a2, base_color);
    color += alpha * direct_lighting * indirect;
    indirect *= occlusion;

    if (alpha < 1.0 && transparency_bounces < MAX_TRANSPARENCY_BOUNCES) {
      ++transparency_bounces;

      indirect *= (1.0 - alpha);
      ray.origin = pos - NORMAL_DELTA * n;

    } else {
      ++light_bounces;

      float diffuse_pdf;
      vec3 diffuse_dir = diffuse_sample(n, diffuse_pdf);

      float microfacet_pdf;
      vec3 microfacet_dir = microfacet_sample(n, -ray.dir, a2, microfacet_pdf);

      vec3 dir;
      float c;
      if (rand_float() < metal) {
        dir = microfacet_dir;
        c = metal;
      } else {
        dir = diffuse_dir;
        c = 1.0 - metal;
      }

      float pdf = c * (diffuse_pdf + microfacet_pdf);

      float n_dot_l = max(dot(n, dir), 0.0);
      indirect *= microfacet_brdf(n, -ray.dir, dir, metal, a2, base_color) * n_dot_l / pdf;

      ray.origin = pos + NORMAL_DELTA * n;
      ray.dir = dir;
    }
  }

  return color;
}

// <---------------------------------Main------------------------------------->

void main() {
  ivec2 id = ivec2(gl_GlobalInvocationID.xy);
  if (id.x >= resolution_x || id.y >= resolution_y) return;

  uint index = id.y * resolution_x + id.x;
  rand_state = index ^ seed;

  vec3 color = vec3(0.0);
  uint nan_count = 0;
  for (uint i = 0; i < sample_count; ++i) {
    vec3 pixel_center = camera.corner_pixel_pos + 
      (id.x + rand_float() - 0.5) * camera.pixel_delta_u +
      (id.y + rand_float() - 0.5) * camera.pixel_delta_v;

    Ray ray;
    ray.origin = camera.pos;
    ray.dir = normalize(pixel_center - camera.pos);

    vec3 ray_color = get_ray_color(ray);
    if (isnan(ray_color.x) || isnan(ray_color.y) || isnan(ray_color.z)) {
      ++nan_count;
    } else {
      color += ray_color;
    }
  }
  color /= (sample_count - nan_count);

  color = pow(color, vec3(1.0 / GAMMA));

  imageStore(result, id, vec4(color, 1.0));
}