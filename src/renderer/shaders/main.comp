#version 460
#extension GL_EXT_nonuniform_qualifier : require

// <----------------------Specialization Constants---------------------------->

layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;
layout (constant_id = 2) const uint MATERIAL_COUNT = 1;
layout (constant_id = 3) const uint DIRECTIONAL_LIGHT_COUNT = 1;
layout (constant_id = 4) const uint POINT_LIGHT_COUNT = 1;
layout (constant_id = 5) const uint BVH_MAX_DEPTH = 16;

#define PI 3.1415926535
#define GAMMA 2.2
#define INFINITY 3.4e+38
#define NORMAL_DELTA 1e-3
#define LIGHT_INTENSITY_FACTOR 10.0
#define POINT_LIGHT_RADIUS 0.15

// <--------------------------------Structs----------------------------------->

struct Vertex {
  vec3 pos;
  vec3 normal;
  float uv_u;
  vec3 tangent;
  float uv_v;
  vec3 bitangent;
  uint material_idx;
};

struct BVHNode {
  vec3 aabb_min;
  uint left_or_begin;
  vec3 aabb_max;
  uint tri_count;
};

struct Material {
  vec4 base_color;
  int base_color_texture_idx;

  float metallic;
  float roughness;
  int metallic_roughness_texture_idx;

  float normal_scale;
  int normal_texture_idx;

  float occlusion_strength;
  int occlusion_texture_idx;
  
  vec3 emissive_factor;
  int emissive_texture_idx;
};

struct DirectionalLight {
  vec3 color;
  float intensity;
  vec3 dir;
};

struct PointLight {
  vec3 color;
  float intensity;
  vec3 pos;
};

struct Camera {
  vec3 pos;
  vec3 pixel_delta_u, pixel_delta_v;
  vec3 corner_pixel_pos;
};

struct Ray {
  vec3 origin;
  vec3 dir;
};

struct IntersectInfo {
  float t;
  float u, v;
  uint triangle_idx;
};

// <------------------------------Descriptors--------------------------------->

layout (set = 0, binding = 0) buffer position_SSBO {
  vec3 positions[][3];
};

layout (set = 0, binding = 1) readonly buffer triangle_SSBO {
  Vertex triangles[][3];
};

layout (set = 0, binding = 2) readonly buffer bvh_SSBO {
  BVHNode bvh_nodes[];
};

layout (set = 0, binding = 3) uniform material_UBO {
  Material materials[MATERIAL_COUNT];
};

layout (set = 0, binding = 4) uniform directional_light_UBO {
  DirectionalLight directional_lights[DIRECTIONAL_LIGHT_COUNT + 1];
};

layout (set = 0, binding = 5) uniform point_light_UBO {
  PointLight point_lights[POINT_LIGHT_COUNT + 1];
};

layout (set = 0, binding = 6) uniform sampler2D textures[];

layout (set = 0, binding = 7, rgba8) uniform writeonly image2D result;

layout (push_constant) uniform constant {
  Camera camera;
  uint resolution_x, resolution_y;
  uint seed;
  uint sample_count;
  vec3 bg_color;
};

// <----------------------------------RNG------------------------------------->

// https://nullprogram.com/blog/2018/07/31/
void triple32(inout uint x) {
  x ^= x >> 17;
  x *= 0xed5ad4bbU;
  x ^= x >> 11;
  x *= 0xac4c1b51U;
  x ^= x >> 15;
  x *= 0x31848babU;
  x ^= x >> 14;
}

uint rand_state;
float rand_float() {
  triple32(rand_state);
  return float(rand_state) / float(~0u);
}

vec3 rand_dir() {
  float z = 2.0 * rand_float() - 1.0;
  float l = sqrt(1.0 - z * z);
  float theta = 2.0 * PI * rand_float();
  return vec3(l * cos(theta), l * sin(theta), z);
}

// <-------------------------Ray-AABB-Intersection---------------------------->

bool ray_aabb_intersect(const Ray ray, const vec3 aabb_min, const vec3 aabb_max, out float t) {
  vec3 inv_dir = 1.0 / ray.dir;
  vec3 t_min = inv_dir * (aabb_min - ray.origin);
  vec3 t_max = inv_dir * (aabb_max - ray.origin);
  vec3 t1 = min(t_min, t_max);
  vec3 t2 = max(t_min, t_max);
  float t_near = max(max(t1.x, t1.y), t1.z);
  float t_far  = min(min(t2.x, t2.y), t2.z);

  t = t_near;
  if (t_near <= t_far) {
    return true;

  } else {
    return false;
  }
}

// <---------------------Ray-Triangle-Intersection---------------------------->

void ray_triangle_intersect(
    const Ray ray,
    const uint triangle_idx,
    inout IntersectInfo info) {

  vec3 pos[3] = positions[triangle_idx];
  vec3 edge1 = pos[1] - pos[0];
  vec3 edge2 = pos[2] - pos[0];
  vec3 ray_cross_edge2 = cross(ray.dir, edge2);
  float det = dot(edge1, ray_cross_edge2);
  const float epsilon = 1e-6;
  if (abs(det) < epsilon) return;

  float inv_det = 1.0 / det;
  vec3 s = ray.origin - pos[0];
  float u = inv_det * dot(s, ray_cross_edge2);
  if (u < 0.0 || u > 1.0) return;

  vec3 s_cross_edge1 = cross(s, edge1);
  float v = inv_det * dot(ray.dir, s_cross_edge1);
  if (v < 0.0 || u + v > 1.0) return;

  float t = inv_det * dot(edge2, s_cross_edge1);
  if (t > epsilon && t < info.t) {
    info.t = t;
    info.u = u;
    info.v = v;
    info.triangle_idx = triangle_idx;
  }
}

// <-------------------------Ray-Scene-Intersection--------------------------->

#define MIN_STACK_SIZE 64
const uint STACK_SIZE = MIN_STACK_SIZE * (BVH_MAX_DEPTH + MIN_STACK_SIZE - 1) / MIN_STACK_SIZE;
uint stack[STACK_SIZE];
void ray_scene_intersect(const Ray ray, inout IntersectInfo info) {
  uint top = 0;
  stack[top++] = 0;

  while (top != 0) {
    BVHNode node = bvh_nodes[stack[--top]];

    if (node.tri_count > 0) {
      for (uint i = 0; i < node.tri_count; ++i) {
        ray_triangle_intersect(ray, node.left_or_begin + i, info);
      }
    } else {
      BVHNode left  = bvh_nodes[node.left_or_begin];
      BVHNode right = bvh_nodes[node.left_or_begin + 1];

      float dist_left, dist_right;
      bool left_intersected  = ray_aabb_intersect(ray, left.aabb_min, left.aabb_max, dist_left);
      bool right_intersected = ray_aabb_intersect(ray, right.aabb_min, right.aabb_max, dist_right);

      if (left_intersected && right_intersected) {
        if (dist_left < dist_right) {
          stack[top++] = node.left_or_begin + 1;
          stack[top++] = node.left_or_begin;
        } else {
          stack[top++] = node.left_or_begin;
          stack[top++] = node.left_or_begin + 1;
        }

      } else if (left_intersected) {
        stack[top++] = node.left_or_begin;

      } else if (right_intersected) {
        stack[top++] = node.left_or_begin + 1;
      }
    }
  }
}

// <-----------------------------Utility-------------------------------------->

vec4 sample_texture(uint index, vec2 texcoord) {
  if (index == -1) return vec4(1.0);
  return texture(textures[nonuniformEXT(index)], texcoord);
}

void get_interpolated_data(IntersectInfo intersect_info, 
    out vec3 pos, out vec3 normal, out vec2 texcoord, out uint material_idx) {
  Vertex vertices[3] = triangles[intersect_info.triangle_idx];
  float u = intersect_info.u;
  float v = intersect_info.v;
  float w = 1.0 - u - v;

  pos = w * vertices[0].pos + u * vertices[1].pos + v * vertices[2].pos;
  normal = w * vertices[0].normal + u * vertices[1].normal + v * vertices[2].normal;
  texcoord = 
    w * vec2(vertices[0].uv_u, vertices[0].uv_v) +
    u * vec2(vertices[1].uv_u, vertices[1].uv_v) +
    v * vec2(vertices[2].uv_u, vertices[2].uv_v);
  material_idx = vertices[0].material_idx;
}

void get_material_data(uint material_idx, vec2 texcoord,
    out vec3 base_color, out float alpha, out float metallic,
    out float roughness, out vec3 emission, out float occlusion) {

  Material mat = materials[material_idx];
  
  vec4 base_color_srgb = mat.base_color * sample_texture(mat.base_color_texture_idx, texcoord);
  base_color = base_color_srgb.rgb;
  base_color = pow(base_color, vec3(GAMMA));
  alpha = base_color_srgb.a;

  vec2 roughness_metallic = sample_texture(mat.metallic_roughness_texture_idx, texcoord).bg;
  metallic = mat.metallic * roughness_metallic[0];
  roughness = mat.roughness * roughness_metallic[1];

  emission = mat.emissive_factor * sample_texture(mat.emissive_texture_idx, texcoord).rgb;
  emission = pow(emission, vec3(GAMMA));
  emission *= LIGHT_INTENSITY_FACTOR;

  occlusion = 1.0 + mat.occlusion_strength * (sample_texture(mat.occlusion_texture_idx, texcoord).r - 1.0);
}

// <--------------------------------BRDF-------------------------------------->

// float distribution_GGX(vec3 n, vec3 h, float a2) {
//   float n_dot_h = max(dot(n, h), 0.0);
//   if (n_dot_h == 0.0) return 0.0;
//   float denom = n_dot_h * n_dot_h * (a2 - 1.0) + 1.0;
//   denom = PI * denom * denom;
//   return a2 / denom;
// }

// float geometry_smith1(vec3 n, vec3 h, vec3 x, float a2) {
//   float n_dot_x = dot(n, x);
//   float denom = abs(n_dot_x) + sqrt(a2 + (1.0 - a2) * n_dot_x * n_dot_x);
//   return step(0.0, dot(h, x)) / denom;
// }

// float geometry_smith2(vec3 n, vec3 h, vec3 v, vec3 l, float a2) {
//   return geometry_smith1(n, h, l, a2) * geometry_smith1(n, h, v, a2);
// }

// vec3 brdf(vec3 n, vec3 v, vec3 l, float metallic, float roughness, vec3 base_color) {
//   float a2 = roughness * roughness;
//   vec3 h = normalize(l + v);

//   vec3 f0 = mix(vec3(0.04), base_color, metallic);
//   vec3 f = f0 + (1.0 - f0) * pow(1.0 - abs(dot(v, h)), 5.0);

//   vec3 diffuse = (1.0 - f) * (1.0 - metallic) * base_color / PI;
//   vec3 specular = f * distribution_GGX(n, h, a2) * geometry_smith2(n, h, l, v, a2);
//   return diffuse + specular;
// }

vec3 brdf(vec3 n, vec3 v, vec3 l, float metallic, float roughness, vec3 base_color) {
  return base_color / PI;
}

// <----------------------------Lighting------------------------------------->

vec3 direct_lighting(vec3 n, vec3 v, vec3 pos, float metallic, float roughness, vec3 base_color) {
  vec3 color = vec3(0.0);

  for (uint i = 0; i < DIRECTIONAL_LIGHT_COUNT; ++i) {
    DirectionalLight light = directional_lights[i];
    vec3 l = -light.dir;

    IntersectInfo info;
    info.t = INFINITY;
    info.triangle_idx = -1;
    Ray ray;
    ray.origin = pos + NORMAL_DELTA * n;
    ray.dir = l;
    ray_scene_intersect(ray, info);
    if (info.triangle_idx != -1) continue;

    light.intensity *= (4.0 * PI / 683.0);
    light.intensity /= LIGHT_INTENSITY_FACTOR;
    vec3 radiance = light.color * light.intensity;

    float n_dot_l = max(dot(n, l), 0.0);
    color += radiance * brdf(n, v, l, metallic, roughness, base_color) * n_dot_l;
  }

  for (uint i = 0; i < POINT_LIGHT_COUNT; ++i) {
    PointLight light = point_lights[i];

    light.pos += rand_dir() * POINT_LIGHT_RADIUS;

    vec3 l = light.pos - pos;
    float dist = length(l);
    l /= dist;

    IntersectInfo info;
    info.t = INFINITY;
    info.triangle_idx = -1;
    Ray ray;
    ray.origin = pos;
    ray.dir = l;
    ray_scene_intersect(ray, info);
    if (info.triangle_idx != -1 && info.t < dist) continue;

    float attenuation = 1.0 / (dist * dist);
    light.intensity *= (4.0 * PI / 683.0);
    light.intensity /= LIGHT_INTENSITY_FACTOR;
    vec3 radiance = light.color * light.intensity * attenuation;

    float n_dot_l = max(dot(n, l), 0.0);
    color += radiance * brdf(n, v, l, metallic, roughness, base_color) * n_dot_l;
  }

  return color;
}

vec3 get_ray_color(Ray ray) {
  vec3 final_color = vec3(0.0);
  vec3 indirect = vec3(1.0);

  const uint MAX_TRANSPARENCY_BOUNCES = 4;
  uint transparency_bounces = 0;
  const uint MAX_DIFFUSE_BOUNCES = 16;
  uint diffuse_bounces = 0;

  while (diffuse_bounces < MAX_DIFFUSE_BOUNCES) {
    IntersectInfo intersect_info;
    intersect_info.t = INFINITY;
    intersect_info.triangle_idx = -1;
    ray_scene_intersect(ray, intersect_info);
    if (intersect_info.triangle_idx == -1) {
      final_color += indirect * pow(bg_color, vec3(GAMMA));
      break;
    }

    vec3 pos, normal;
    vec2 texcoord;
    uint material_idx;
    get_interpolated_data(intersect_info, pos, normal, texcoord, material_idx);
    if (dot(normal, ray.dir) > 0.0) normal *= -1.0;

    vec3 base_color, emission;
    float alpha, roughness, metallic, occlusion;
    get_material_data(
      material_idx, texcoord,
      base_color, alpha, metallic,
      roughness, emission, occlusion
    );

    vec3 color = direct_lighting(normal, -ray.dir, pos, metallic, roughness, base_color);
    color += emission;
    indirect *= occlusion;

    if (alpha < 1.0 && transparency_bounces < MAX_TRANSPARENCY_BOUNCES) {
      ++transparency_bounces;

      final_color += alpha * color * indirect;
      indirect *= (1.0 - alpha);

      ray.origin = pos - NORMAL_DELTA * normal;

    } else {
      ++diffuse_bounces;

      final_color += color * indirect;
      
      vec3 dir = rand_dir();
      if (dot(dir, normal) < 0.0) dir *= -1.0;
      dir = normalize(normal + dir);

      float n_dot_l = max(dot(normal, dir), 0.0);
      indirect *= brdf(normal, -ray.dir, dir, metallic, roughness, base_color) * PI;

      ray.origin = pos + NORMAL_DELTA * normal;
      ray.dir = dir;
    }
  }

  return final_color;
}

// <---------------------------------Main------------------------------------->

void main() {
  ivec2 id = ivec2(gl_GlobalInvocationID.xy);
  if (id.x >= resolution_x || id.y >= resolution_y) return;

  uint index = id.y * resolution_x + id.x;
  rand_state = index ^ seed;

  vec3 color = vec3(0.0);
  for (uint i = 0; i < sample_count; ++i) {
    vec3 pixel_center = camera.corner_pixel_pos + 
      (id.x + rand_float() - 0.5) * camera.pixel_delta_u +
      (id.y + rand_float() - 0.5) * camera.pixel_delta_v;

    Ray ray;
    ray.origin = camera.pos;
    ray.dir = normalize(pixel_center - camera.pos);

    color += get_ray_color(ray);
  }
  color /= sample_count;

  color = pow(color, vec3(1.0 / GAMMA));

  imageStore(result, id, vec4(color, 1.0));
}