#version 460

// <--------------------------------Input------------------------------------->
layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

struct Vertex {
  vec3 pos;
  vec3 normal;
};

struct Triangle {
  Vertex v[3];
};

struct BVHNode {
  vec3 aabb_min;
  uint left_or_begin;
  vec3 aabb_max;
  uint triangle_count;
};

struct Camera {
  vec3 center;
  vec3 pixel_delta_u, pixel_delta_v;
  vec3 corner_pixel_pos;
};

layout (set = 0, binding = 0) readonly buffer triangles_ssbo {
  Triangle triangles[];
};

layout (set = 0, binding = 1) readonly buffer bvh_ssbo {
  BVHNode bvh_nodes[];
};

layout (set = 0, binding = 2) writeonly buffer result_ssbo {
  vec4 result[];
};

layout (push_constant) uniform constant {
  Camera camera;
  uint image_width, image_height;
  uint seed;
  uint sample_count;
  uint triangle_count;
};

// <----------------------------------RNG------------------------------------->
// https://nullprogram.com/blog/2018/07/31/
void triple32(inout uint x) {
  x ^= x >> 17;
  x *= 0xed5ad4bbU;
  x ^= x >> 11;
  x *= 0xac4c1b51U;
  x ^= x >> 15;
  x *= 0x31848babU;
  x ^= x >> 14;
}

uint rand_state;
float rand_float() {
  triple32(rand_state);
  return float(rand_state) / float(~0u);
}

// <----------------------------------Ray------------------------------------->
struct Ray {
  vec3 origin;
  vec3 dir;
};

Ray get_ray_through_pixel(const uint x, const uint y) {
  vec3 pixel_center = 
    camera.corner_pixel_pos + 
    (rand_float() - 0.5 + x) * camera.pixel_delta_u +
    (rand_float() - 0.5 + y) * camera.pixel_delta_v;

  Ray ray;
  ray.origin = camera.center;
  ray.dir = normalize(pixel_center - ray.origin);
  return ray;
}

// <-------------------------Ray-AABB-Intersection---------------------------->
bool ray_aabb_intersect(const Ray ray, const vec3 aabb_min, const vec3 aabb_max) {
  vec3 inv_dir = 1.0 / ray.dir;
  vec3 t_min = inv_dir * (aabb_min - ray.origin);
  vec3 t_max = inv_dir * (aabb_max - ray.origin);
  vec3 t1 = min(t_min, t_max);
  vec3 t2 = max(t_min, t_max);
  float t_near = max(max(t1.x, t1.y), t1.z);
  float t_far  = min(min(t2.x, t2.y), t2.z);
  return t_near <= t_far;
}

// <---------------------Ray-Triangle-Intersection---------------------------->
struct Intersection {
  vec3 pos, normal;
  float t;
};

void ray_triangle_intersect(
    const Ray ray,
    const Triangle triangle,
    inout Intersection intersection) {

  vec3 edge1 = triangle.v[1].pos - triangle.v[0].pos;
  vec3 edge2 = triangle.v[2].pos - triangle.v[0].pos;
  vec3 ray_cross_edge2 = cross(ray.dir, edge2);
  float det = dot(edge1, ray_cross_edge2);
  const float epsilon = 1e-4;
  if (abs(det) < epsilon) return;

  float inv_det = 1.0 / det;
  vec3 s = ray.origin - triangle.v[0].pos;
  float u = inv_det * dot(s, ray_cross_edge2);
  if (u < 0.0 || u > 1.0) return;

  vec3 s_cross_edge1 = cross(s, edge1);
  float v = inv_det * dot(ray.dir, s_cross_edge1);
  if (v < 0.0 || u + v > 1.0) return;

  float t = inv_det * dot(edge2, s_cross_edge1);
  if (t > epsilon && t < intersection.t) {
    float w = 1.0 - u - v;
    intersection.t = t;
    intersection.pos = w * triangle.v[0].pos + u * triangle.v[1].pos + v * triangle.v[2].pos;
    intersection.normal = normalize(
      w * triangle.v[0].normal + u * triangle.v[1].normal + v * triangle.v[2].normal
    );
  }
}

// <-------------------------Ray-Scene-Intersection--------------------------->
#define STACK_SIZE 32
uint stack[STACK_SIZE];
void ray_scene_intersect(const Ray ray, inout Intersection intersection) {
  uint top = 0;
  stack[top++] = 0;

  while (top != 0) {
    if (top >= STACK_SIZE) return;
    BVHNode node = bvh_nodes[stack[--top]];

    if (!ray_aabb_intersect(ray, node.aabb_min, node.aabb_max)) continue;

    if (node.triangle_count > 0) {
      for (uint i = 0; i < node.triangle_count; ++i) {
        ray_triangle_intersect(ray, triangles[node.left_or_begin + i], intersection);
      }
    } else {
      stack[top++] = node.left_or_begin;
      stack[top++] = node.left_or_begin + 1;
    }
  }
}

void ray_scene_intersect2(const Ray ray, inout Intersection intersection) {
  for (uint i = 0; i < triangle_count; ++i) {
    ray_triangle_intersect(ray, triangles[i], intersection);
  }
}

// <-------------------------------Ray-color---------------------------------->
vec3 get_ray_color(const Ray ray) {
  float a = 0.5 * (ray.dir.y + 1.0);
  vec3 color = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);

  Intersection intersection;
  intersection.t = 1.0 / 0.0;
  ray_scene_intersect(ray, intersection);

  if (!isinf(intersection.t)) {
    color = 0.5 * (1.0 + intersection.normal);
  }

  return color;
}

// <---------------------------------Main------------------------------------->
void main() {
  uint id_x = gl_GlobalInvocationID.y;
  uint id_y = gl_GlobalInvocationID.x;
  if (id_x >= image_width || id_y >= image_height) return;

  uint index = id_y * image_width + id_x;
  rand_state = index ^ seed;

  vec3 color = vec3(0.0);
  for (uint i = 0; i < sample_count; ++i) {
    Ray ray = get_ray_through_pixel(id_x, id_y);
    color += get_ray_color(ray);
  }
  color /= sample_count;

  result[index] = vec4(color, 1.0f);
}