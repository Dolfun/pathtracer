#version 460
#extension GL_EXT_nonuniform_qualifier : require

// <----------------------Specialization Constants---------------------------->

layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;
layout (constant_id = 2) const uint MATERIAL_COUNT = 1;
layout (constant_id = 3) const uint DIRECTIONAL_LIGHT_COUNT = 1;
layout (constant_id = 4) const uint POINT_LIGHT_COUNT = 1;


// <--------------------------------Structs----------------------------------->

struct Vertex {
  vec3 pos;
  vec3 normal;
  float uv_u;
  vec3 tangent;
  float uv_v;
  vec3 bitangent;
  uint material_idx;
};

struct BVHNode {
  vec3 aabb_min;
  uint left_or_begin;
  vec3 aabb_max;
  uint tri_count;
};

struct Material {
  vec4 base_color;
  int base_color_texture_idx;

  float metalness;
  float roughness;
  int metallic_roughness_texture_idx;

  float normal_scale;
  int normal_texture_idx;

  float occlusion_strength;
  int occlusion_texture_idx;
  
  vec3 emissive_factor;
  int emissive_texture_idx;
};

struct DirectionalLight {
  vec3 dir;
  float intensity;
  vec3 color;
};

struct PointLight {
  vec3 pos;
  float range;
  vec3 color;
  float intensity;
};

struct Camera {
  vec3 pos;
  vec3 pixel_delta_u, pixel_delta_v;
  vec3 corner_pixel_pos;
};

struct Ray {
  vec3 origin;
  vec3 dir;
};

struct IntersectInfo {
  float t;
  float u, v;
  uint triangle_idx;
};

// <------------------------------Descriptors--------------------------------->

layout (set = 0, binding = 0) writeonly buffer result_SSBO {
  vec4 result[];
};

layout (set = 0, binding = 1) buffer position_SSBO {
  vec3 positions[][3];
};

layout (set = 0, binding = 2) readonly buffer triangle_SSBO {
  Vertex triangles[][3];
};

layout (set = 0, binding = 3) readonly buffer bvh_SSBO {
  BVHNode bvh_nodes[];
};

layout (set = 0, binding = 4) uniform material_UBO {
  Material materials[MATERIAL_COUNT];
};

layout (set = 0, binding = 5) uniform directional_light_UBO {
  DirectionalLight directional_lights[DIRECTIONAL_LIGHT_COUNT + 1];
};

layout (set = 0, binding = 6) uniform point_light_UBO {
  PointLight point_lights[POINT_LIGHT_COUNT + 1];
};

layout(binding = 7) uniform sampler2D samplers[];

layout (push_constant) uniform constant {
  Camera camera;
  uint resolution_x, resolution_y;
  uint seed;
  uint sample_count;
  vec3 bg_color;
};

// <----------------------------------RNG------------------------------------->

// https://nullprogram.com/blog/2018/07/31/
void triple32(inout uint x) {
  x ^= x >> 17;
  x *= 0xed5ad4bbU;
  x ^= x >> 11;
  x *= 0xac4c1b51U;
  x ^= x >> 15;
  x *= 0x31848babU;
  x ^= x >> 14;
}

uint rand_state;
float rand_float() {
  triple32(rand_state);
  return float(rand_state) / float(~0u);
}

// <----------------------------------Ray------------------------------------->

Ray get_ray_through_pixel(const uint x, const uint y) {
  vec3 pixel_center = 
    camera.corner_pixel_pos + 
    (rand_float() - 0.5 + x) * camera.pixel_delta_u +
    (rand_float() - 0.5 + y) * camera.pixel_delta_v;

  Ray ray;
  ray.origin = camera.pos;
  ray.dir = normalize(pixel_center - ray.origin);
  return ray;
}

// <-------------------------Ray-AABB-Intersection---------------------------->

bool ray_aabb_intersect(const Ray ray, const vec3 aabb_min, const vec3 aabb_max, out float t) {
  vec3 inv_dir = 1.0 / ray.dir;
  vec3 t_min = inv_dir * (aabb_min - ray.origin);
  vec3 t_max = inv_dir * (aabb_max - ray.origin);
  vec3 t1 = min(t_min, t_max);
  vec3 t2 = max(t_min, t_max);
  float t_near = max(max(t1.x, t1.y), t1.z);
  float t_far  = min(min(t2.x, t2.y), t2.z);

  t = t_near;
  if (t_near <= t_far) {
    return true;

  } else {
    return false;
  }
}

// <---------------------Ray-Triangle-Intersection---------------------------->

void ray_triangle_intersect(
    const Ray ray,
    const uint triangle_idx,
    inout IntersectInfo info) {

  vec3 pos[3] = positions[triangle_idx];
  vec3 edge1 = pos[1] - pos[0];
  vec3 edge2 = pos[2] - pos[0];
  vec3 ray_cross_edge2 = cross(ray.dir, edge2);
  float det = dot(edge1, ray_cross_edge2);
  const float epsilon = 1e-6;
  if (abs(det) < epsilon) return;

  float inv_det = 1.0 / det;
  vec3 s = ray.origin - pos[0];
  float u = inv_det * dot(s, ray_cross_edge2);
  if (u < 0.0 || u > 1.0) return;

  vec3 s_cross_edge1 = cross(s, edge1);
  float v = inv_det * dot(ray.dir, s_cross_edge1);
  if (v < 0.0 || u + v > 1.0) return;

  float t = inv_det * dot(edge2, s_cross_edge1);
  if (t > epsilon && t < info.t) {
    info.t = t;
    info.u = u;
    info.v = v;
    info.triangle_idx = triangle_idx;
  }
}

// <-------------------------Ray-Scene-Intersection--------------------------->

#define STACK_SIZE 64
uint stack[STACK_SIZE];
void ray_scene_intersect(const Ray ray, inout IntersectInfo info) {
  uint top = 0;
  stack[top++] = 0;

  while (top != 0) {
    if (top >= STACK_SIZE) return;
    BVHNode node = bvh_nodes[stack[--top]];

    if (node.tri_count > 0) {
      for (uint i = 0; i < node.tri_count; ++i) {
        ray_triangle_intersect(ray, node.left_or_begin + i, info);
      }
    } else {
      BVHNode left  = bvh_nodes[node.left_or_begin];
      BVHNode right = bvh_nodes[node.left_or_begin + 1];

      float dist_left, dist_right;
      bool left_intersected  = ray_aabb_intersect(ray, left.aabb_min, left.aabb_max, dist_left);
      bool right_intersected = ray_aabb_intersect(ray, right.aabb_min, right.aabb_max, dist_right);

      if (left_intersected && right_intersected) {
        if (dist_left < dist_right) {
          stack[top++] = node.left_or_begin + 1;
          stack[top++] = node.left_or_begin;
        } else {
          stack[top++] = node.left_or_begin;
          stack[top++] = node.left_or_begin + 1;
        }

      } else if (left_intersected) {
        stack[top++] = node.left_or_begin;

      } else if (right_intersected) {
        stack[top++] = node.left_or_begin + 1;
      }
    }
  }
}

// <-------------------------------Ray-color---------------------------------->

const float gamma = 2.2;
vec3 get_ray_color(Ray ray) {
  vec3 color = vec3(0.0);

  float current_alpha = 1.0;
  const uint MAX_DEPTH = 4;
  uint current_depth;
  for (current_depth = 0; current_depth < MAX_DEPTH; ++current_depth) {
    IntersectInfo intersect_info;
    intersect_info.t = 1.0 / 0.0;
    intersect_info.triangle_idx = -1;
    ray_scene_intersect(ray, intersect_info);

    if (intersect_info.triangle_idx == -1) {
      color += current_alpha * bg_color;
      break;
    }

    Vertex vertices[3] = triangles[intersect_info.triangle_idx];
    float u = intersect_info.u;
    float v = intersect_info.v;
    float w = 1.0 - u - v;

    vec2 texcoords[3];
    for (int i = 0; i < 3; ++i) {
      texcoords[i] = vec2(vertices[i].uv_u, vertices[i].uv_v);
    }
    vec2 texcoord = w * texcoords[0] + u * texcoords[1] + v * texcoords[2];

    Material mat = materials[vertices[0].material_idx];
    vec4 base_color = mat.base_color;
    if (mat.base_color_texture_idx != -1) {
      vec4 sampled_color = texture(samplers[nonuniformEXT(mat.base_color_texture_idx)], texcoord);
      sampled_color.rgb = pow(sampled_color.rgb, vec3(gamma));
      base_color *= sampled_color;
    }

    color += current_alpha * base_color.rgb * base_color.a;
    current_alpha *= 1.0 - base_color.a;

    if (base_color.a == 1.0) {
      break;
    }

    vec3 pos = w * vertices[0].pos + u * vertices[1].pos + v * vertices[2].pos;
    vec3 normal = w * vertices[0].normal + u * vertices[1].normal + v * vertices[2].normal;
    if (dot(normal, ray.dir) < 0.0) normal *= -1.0;
    float epsilon = 1e-3;
    ray.origin = pos + epsilon * normal;
  }

  if (current_depth == MAX_DEPTH) {
    color += current_alpha * bg_color;
  }

  return color;
}

// <---------------------------------Main------------------------------------->

void main() {
  uint id_x = gl_GlobalInvocationID.y;
  uint id_y = gl_GlobalInvocationID.x;
  if (id_x >= resolution_x || id_y >= resolution_y) return;

  uint index = id_y * resolution_x + id_x;
  rand_state = index ^ seed;

  vec3 color = vec3(0.0);
  for (uint i = 0; i < sample_count; ++i) {
    Ray ray = get_ray_through_pixel(id_x, id_y);
    color += get_ray_color(ray);
  }
  color /= sample_count;

  color.rgb = pow(color.rgb, vec3(1.0 / gamma));

  result[index] = vec4(color, 1.0f);
}